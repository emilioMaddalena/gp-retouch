{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"gp-retouch","text":"<p><code>gp-retouch</code> is a Gaussian process-based image processing package.</p> <p>This project aims to provide users with an easy-to-use toolbox for image processing, abstracting most of the low-level machine learning technicalities (\u00e0 la scikit-learn).</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Image reconstruction using Gaussian Processes</li> <li>Image denoising</li> <li>Simple API for image manipulation</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation</li> <li>Usage Examples</li> <li>API Reference</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions to gp-retouch are welcome! Here's how you can help:</p>"},{"location":"contributing/#set-up-development-environment","title":"Set Up Development Environment","text":"<ol> <li> <p>Clone the repository:    <pre><code>git clone https://github.com/emilioMaddalena/gp-retouch.git\ncd gp-retouch\n</code></pre></p> </li> <li> <p>Install in development mode:    <pre><code>pip install -e .\n</code></pre></p> </li> <li> <p>Install development dependencies:    <pre><code>pip install pytest ruff\n</code></pre></p> </li> </ol>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>This project uses Ruff for linting. To check your code:</p> <pre><code>ruff check .\n</code></pre>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"<p>Tests are run using pytest:</p> <pre><code>pytest\n</code></pre>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Create a new branch for your feature or bugfix</li> <li>Make your changes</li> <li>Run tests and linter</li> <li>Submit a pull request</li> </ol>"},{"location":"installation/","title":"Installation","text":"<p>You can install gp-retouch using pip:</p> <pre><code>pip install gp-retouch\n</code></pre>"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>If you want to contribute to gp-retouch, you can install it in development mode:</p> <pre><code>git clone https://github.com/emilioMaddalena/gp-retouch.git\ncd gp-retouch\npip install -e .\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>Here are some examples of how to use gp-retouch for image processing.</p>"},{"location":"usage/#basic-usage","title":"Basic Usage","text":"<pre><code>from gp_retouch.image import Image\nimport numpy as np\n\n# Create a new image\ndata = np.zeros((100, 100))\nimg = Image(data)\n\n# Plot the image\nimg.plot()\n</code></pre>"},{"location":"usage/#checking-image-properties","title":"Checking Image Properties","text":"<pre><code># Check if image is grayscale\nprint(img.is_grayscale)\n\n# Get image dimensions\nprint(f\"Width: {img.width}, Height: {img.height}\")\n</code></pre> <p>More usage examples will be added as the project develops.</p>"},{"location":"api/image/","title":"Image Module","text":"<p>This module contains the core image processing functionality.</p>"},{"location":"api/image/#image-class","title":"Image Class","text":"<p>Represents an image and provides the user basic manipulation methods.</p> <p>It encapsulates an image data and metadata, and provides manipulation tools such as rescaling it, converting it to greyscale, plotting and saving it, etc.</p> Source code in <code>gp_retouch/image/image.py</code> <pre><code>class Image:\n    \"\"\"Represents an image and provides the user basic manipulation methods.\n\n    It encapsulates an image data and metadata, and provides manipulation tools such as\n    rescaling it, converting it to greyscale, plotting and saving it, etc.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: np.ndarray,\n        metadata: Optional[Dict] = None,\n    ):\n        \"\"\"Load the image.\n\n        Args:\n            data (np.ndarray): the image's actual data.\n            metadata (Optional[Dict], optional): any extra info about the data.\n        \"\"\"\n        self._data = None\n        self.data = data\n        self.metadata = metadata or {}\n\n    @property\n    def data(self) -&gt; np.ndarray:\n        \"\"\"Get the image data.\"\"\"\n        return self._data\n\n    @data.setter\n    def data(self, value: np.ndarray):\n        \"\"\"Set the image data, ensuring values are between 0 and 255.\"\"\"\n        if not np.all(np.isnan(value) | ((MIN_PIXEL_VALUE &lt;= value) &amp; (value &lt;= MAX_PIXEL_VALUE))):\n            raise ValueError(\"All values in the image data must be between 0 and 255, or NaNs.\")\n        self._data = value.astype(PIXEL_DATA_TYPE)\n\n    @property\n    def is_grayscale(self) -&gt; bool:\n        \"\"\"Check if the image is grayscale.\"\"\"\n        return True if len(self.data.shape) == 2 else False\n\n    @property\n    def is_rgb(self) -&gt; bool:\n        \"\"\"Check if the image is RGB.\"\"\"\n        return True if (len(self.data.shape) == 3) and (self.data.shape[2] == 3) else False\n\n    @property\n    def shape(self) -&gt; tuple:\n        \"\"\"Get the image shape.\"\"\"\n        return self.data.shape\n\n    @property\n    def height(self) -&gt; tuple:\n        \"\"\"Get the image height.\"\"\"\n        if self.is_grayscale:\n            height, _ = self.data.shape\n        elif self.is_rgb:\n            height, _, _ = self.data.shape\n        return height\n\n    @property\n    def width(self) -&gt; tuple:\n        \"\"\"Get the image width.\"\"\"\n        if self.is_grayscale:\n            _, width = self.data.shape\n        elif self.is_rgb:\n            _, width, _ = self.data.shape\n        return width\n\n    @property\n    def is_incomplete(self) -&gt; bool:\n        \"\"\"Check if the image has any NaN values.\"\"\"\n        return np.isnan(self.data).any()\n\n    def get_completeness_ratio(self) -&gt; float:\n        \"\"\"Compute the percentage of pixels that are not nans.\"\"\"\n        return 1 - (np.sum(np.isnan(self.data)) / self.data.size)\n\n    def plot(self, plot_3d: bool = False):\n        \"\"\"Plot the image either in 2D or 3D (only for grayscale images).\n\n        Args:\n            plot_3d (bool, optional): Enables 3D interactive plotting. Defaults to False.\n        \"\"\"\n        if plot_3d:\n            if self.is_rgb:\n                raise ValueError(\"Cannot 3D plot an RGB image.\")\n            fig = plt.figure()\n            ax = fig.add_subplot(111, projection=\"3d\")\n            x, y = np.meshgrid(np.arange(self.data.shape[1]), np.arange(self.data.shape[0]))\n            if self.is_rgb:\n                ax.plot_surface(\n                    x,\n                    y,\n                    self.data[:, :, 0],\n                    rstride=1,\n                    cstride=1,\n                    facecolors=self.data / MAX_PIXEL_VALUE,\n                    shade=False,\n                )\n            else:\n                ax.plot_surface(\n                    x,\n                    y,\n                    self.data,\n                    cmap=\"gray\",\n                    rstride=1,\n                    cstride=1,\n                    vmin=MIN_PIXEL_VALUE,\n                    vmax=MAX_PIXEL_VALUE,\n                )\n            plt.show()\n        else:\n            if self.is_rgb:\n                plt.imshow(self.data.astype(np.uint8))\n            else:\n                plt.imshow(self.data, cmap=\"gray\", vmin=MIN_PIXEL_VALUE, vmax=MAX_PIXEL_VALUE)\n            plt.axis(\"off\")\n            plt.show()\n</code></pre>"},{"location":"api/image/#gp_retouch.image.image.Image.data","title":"data  <code>property</code> <code>writable</code>","text":"<pre><code>data: ndarray\n</code></pre> <p>Get the image data.</p>"},{"location":"api/image/#gp_retouch.image.image.Image.height","title":"height  <code>property</code>","text":"<pre><code>height: tuple\n</code></pre> <p>Get the image height.</p>"},{"location":"api/image/#gp_retouch.image.image.Image.is_grayscale","title":"is_grayscale  <code>property</code>","text":"<pre><code>is_grayscale: bool\n</code></pre> <p>Check if the image is grayscale.</p>"},{"location":"api/image/#gp_retouch.image.image.Image.is_incomplete","title":"is_incomplete  <code>property</code>","text":"<pre><code>is_incomplete: bool\n</code></pre> <p>Check if the image has any NaN values.</p>"},{"location":"api/image/#gp_retouch.image.image.Image.is_rgb","title":"is_rgb  <code>property</code>","text":"<pre><code>is_rgb: bool\n</code></pre> <p>Check if the image is RGB.</p>"},{"location":"api/image/#gp_retouch.image.image.Image.metadata","title":"metadata  <code>instance-attribute</code>","text":"<pre><code>metadata = metadata or {}\n</code></pre>"},{"location":"api/image/#gp_retouch.image.image.Image.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple\n</code></pre> <p>Get the image shape.</p>"},{"location":"api/image/#gp_retouch.image.image.Image.width","title":"width  <code>property</code>","text":"<pre><code>width: tuple\n</code></pre> <p>Get the image width.</p>"},{"location":"api/image/#gp_retouch.image.image.Image.__init__","title":"__init__","text":"<pre><code>__init__(data: ndarray, metadata: Optional[Dict] = None)\n</code></pre> <p>Load the image.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>the image's actual data.</p> required <code>metadata</code> <code>Optional[Dict]</code> <p>any extra info about the data.</p> <code>None</code> Source code in <code>gp_retouch/image/image.py</code> <pre><code>def __init__(\n    self,\n    data: np.ndarray,\n    metadata: Optional[Dict] = None,\n):\n    \"\"\"Load the image.\n\n    Args:\n        data (np.ndarray): the image's actual data.\n        metadata (Optional[Dict], optional): any extra info about the data.\n    \"\"\"\n    self._data = None\n    self.data = data\n    self.metadata = metadata or {}\n</code></pre>"},{"location":"api/image/#gp_retouch.image.image.Image.get_completeness_ratio","title":"get_completeness_ratio","text":"<pre><code>get_completeness_ratio() -&gt; float\n</code></pre> <p>Compute the percentage of pixels that are not nans.</p> Source code in <code>gp_retouch/image/image.py</code> <pre><code>def get_completeness_ratio(self) -&gt; float:\n    \"\"\"Compute the percentage of pixels that are not nans.\"\"\"\n    return 1 - (np.sum(np.isnan(self.data)) / self.data.size)\n</code></pre>"},{"location":"api/image/#gp_retouch.image.image.Image.plot","title":"plot","text":"<pre><code>plot(plot_3d: bool = False)\n</code></pre> <p>Plot the image either in 2D or 3D (only for grayscale images).</p> <p>Parameters:</p> Name Type Description Default <code>plot_3d</code> <code>bool</code> <p>Enables 3D interactive plotting. Defaults to False.</p> <code>False</code> Source code in <code>gp_retouch/image/image.py</code> <pre><code>def plot(self, plot_3d: bool = False):\n    \"\"\"Plot the image either in 2D or 3D (only for grayscale images).\n\n    Args:\n        plot_3d (bool, optional): Enables 3D interactive plotting. Defaults to False.\n    \"\"\"\n    if plot_3d:\n        if self.is_rgb:\n            raise ValueError(\"Cannot 3D plot an RGB image.\")\n        fig = plt.figure()\n        ax = fig.add_subplot(111, projection=\"3d\")\n        x, y = np.meshgrid(np.arange(self.data.shape[1]), np.arange(self.data.shape[0]))\n        if self.is_rgb:\n            ax.plot_surface(\n                x,\n                y,\n                self.data[:, :, 0],\n                rstride=1,\n                cstride=1,\n                facecolors=self.data / MAX_PIXEL_VALUE,\n                shade=False,\n            )\n        else:\n            ax.plot_surface(\n                x,\n                y,\n                self.data,\n                cmap=\"gray\",\n                rstride=1,\n                cstride=1,\n                vmin=MIN_PIXEL_VALUE,\n                vmax=MAX_PIXEL_VALUE,\n            )\n        plt.show()\n    else:\n        if self.is_rgb:\n            plt.imshow(self.data.astype(np.uint8))\n        else:\n            plt.imshow(self.data, cmap=\"gray\", vmin=MIN_PIXEL_VALUE, vmax=MAX_PIXEL_VALUE)\n        plt.axis(\"off\")\n        plt.show()\n</code></pre>"},{"location":"api/image_processor/","title":"Image Processor","text":""},{"location":"api/image_processor/#imageprocessor-class","title":"ImageProcessor Class","text":"<p>Handles low-level image processing tasks.</p> Source code in <code>gp_retouch/image/image_processor.py</code> <pre><code>class ImageProcessor:\n    \"\"\"Handles low-level image processing tasks.\"\"\"\n\n    @staticmethod\n    def downscale(original_image: Image, factor: float) -&gt; Image:\n        \"\"\"Downscale an image by factor.\"\"\"\n        if factor &lt;= 0:\n            raise ValueError(\"The downscale factor must be strictly greater than zero.\")\n        if factor &gt;= 1:\n            raise ValueError(\"The downscale factor must be strictly smaller than one.\")\n        image = copy.deepcopy(original_image)\n        # process the dimensions relative to the size\n        new_shape = (int(image.shape[0] * factor), int(image.shape[1] * factor))\n        if image.is_grayscale:\n            downscaled_data = resize(image.data, new_shape, anti_aliasing=True)\n        if image.is_rgb:\n            downscaled_data = resize(image.data, new_shape + (3,), anti_aliasing=True)\n        image.data = downscaled_data\n        return image\n\n    @staticmethod\n    def convert_to_grayscale(image: Image) -&gt; Image:\n        \"\"\"_summary_.\n\n        Args:\n            image (Image): _description_\n\n        Returns:\n            Image: _description_\n        \"\"\"\n        image_copy = copy.deepcopy(image)\n        if image_copy.is_grayscale:\n            return image\n        if image_copy.is_rgb:\n            image_copy.data = np.mean(image_copy.data, axis=2).astype(np.uint8)\n            return image_copy\n\n    @staticmethod\n    def convert_to_rgb(image: Image) -&gt; np.ndarray:  # noqa: D102\n        pass\n\n    @staticmethod\n    def add_noise(image: Image, method: str = \"gaussian\", **kwargs) -&gt; Image:\n        \"\"\"Taint the image with the noise of your choice.\n\n        Args:\n            image (Image): The input image.\n            method (str, optional): The noise method of choice: gausian, salt_and_pepper,\n                                    speckle, or uniform. Defaults to \"gaussian\".\n            **kwargs: Options to be passed to the individual methods.\n\n        Returns:\n            Image: The result with added noise.\n        \"\"\"\n        methods = {\n            \"gaussian\": ImageProcessor._add_gaussian_noise,\n            \"salt_and_pepper\": ImageProcessor._add_salt_and_pepper_noise,\n            \"speckle\": ImageProcessor._add_speckle_noise,\n            \"uniform\": ImageProcessor._add_uniform_noise,\n        }\n\n        if method not in methods:\n            raise ValueError(f\"Invalid method '{method}'. Valid methods: {list(methods.keys())}\")\n\n        # Dispatch the requested method\n        return methods[method](copy.deepcopy(image), **kwargs)\n\n    @staticmethod\n    def _add_gaussian_noise(image: Image, variance: float) -&gt; Image:\n        \"\"\"Taint the image with Gaussian noise.\"\"\"\n        if variance &lt; 0:\n            raise ValueError(\"Variance must be non-negative.\")\n\n        # Generate Gaussian noise\n        mean = 0\n        std_dev = np.sqrt(variance)\n        noise = np.random.normal(mean, std_dev, image.data.shape)\n        # Add noise to the image\n        image.data = ImageProcessor._conform_to_image_data_reqs(image.data + noise)\n        return image\n\n    @staticmethod\n    def _add_salt_and_pepper_noise(image: Image, amount: float, salt_ratio: float = 0.5) -&gt; Image:\n        \"\"\"Taint the image with salt-and-pepper noise.\"\"\"\n        if not (0 &lt; amount &lt; 1):\n            raise ValueError(\"Amount must be between 0 and 1.\")\n        if not (0 &lt;= salt_ratio &lt;= 1):\n            raise ValueError(\"Salt ratio must be between 0 and 1.\")\n\n        num_pixels = np.prod(image.data.shape[:2])\n        num_salt = int(amount * num_pixels * salt_ratio)\n        num_pepper = int(amount * num_pixels * (1 - salt_ratio))\n\n        # Add salt noise\n        salt_coords = tuple(\n            np.random.randint(0, i, num_salt) for i in image.data.shape[:2]\n        )\n        image.data[salt_coords] = MAX_PIXEL_VALUE\n        # Add pepper noise\n        pepper_coords = tuple(\n            np.random.randint(0, i, num_pepper) for i in image.data.shape[:2]\n        )\n        image.data[pepper_coords] = MIN_PIXEL_VALUE\n        return image\n\n    @staticmethod\n    def _add_speckle_noise(image: Image, variance: float) -&gt; Image:\n        \"\"\"Taint the image with speckle noise.\"\"\"\n        if variance &lt; 0:\n            raise ValueError(\"Variance must be non-negative.\")\n\n        noise = np.random.normal(0, np.sqrt(variance), image.data.shape)\n        image.data = ImageProcessor._conform_to_image_data_reqs(image.data + image.data * noise)\n        return image\n\n    @staticmethod\n    def _add_uniform_noise(image: Image, intensity: float) -&gt; Image:\n        \"\"\"Taint the image with uniform noise.\"\"\"\n        if intensity &lt; 0:\n            raise ValueError(\"Intensity must be non-negative.\")\n\n        noise = np.random.uniform(-intensity, intensity, image.data.shape)\n        image.data = ImageProcessor._conform_to_image_data_reqs(image.data + noise)\n        return image\n\n    @staticmethod\n    def drop_pixels(image: Image, ratio: float, method: str = \"rnd\") -&gt; Image:\n        \"\"\"Drop pixels from the image (turn them into NaNs) using the specified method.\n\n        This method does not transform the image in place.\n\n        Args:\n            image (Image): The image to be transformed.\n            ratio (float): The ratio of points to be dropped.\n            method (str, optional): The method to use for dropping pixels. Defaults to \"rnd\".\n\n        Returns:\n            Image: A new image with some pixels dropped.\n        \"\"\"\n        if not (0 &lt; ratio &lt; 1):\n            raise ValueError(\"ratio must be a greater than 0 and smaller than 1.\")\n\n        new_image = copy.deepcopy(image)\n\n        # Dispatcher for pixel dropping methods\n        methods = {\n            \"rnd\": ImageProcessor._drop_pixels_random,\n            \"rectangle\": ImageProcessor._drop_pixels_rectangle,\n            \"spiral\": ImageProcessor._drop_pixels_spiral,\n        }\n\n        if method not in methods:\n            raise ValueError(f\"Invalid method '{method}'. Valid ones: {list(methods.keys())}\")\n\n        return methods[method](new_image, ratio)\n\n    @staticmethod\n    def _drop_pixels_random(image: Image, ratio: float) -&gt; Image:\n        \"\"\"Drop pixels randomly from the image.\"\"\"\n        n, m = image.shape[0], image.shape[1]\n        num_pixels_drop = round(n * m * ratio)\n        indices_drop = np.random.choice(n * m, size=num_pixels_drop, replace=False)\n        row_drop, col_drop = np.unravel_index(indices_drop, (n, m))\n\n        if image.is_rgb:\n            image.data[row_drop, col_drop, :] = np.nan\n        elif image.is_grayscale:\n            image.data[row_drop, col_drop] = np.nan\n\n        return image\n\n    @staticmethod\n    def _drop_pixels_rectangle(image: Image, ratio: float) -&gt; Image:\n        \"\"\"Drop pixels in a rectangular region.\"\"\"\n        height, width = image.height, image.width\n        rect_height = int(height * ratio)\n        rect_width = int(width * ratio)\n        x = np.random.randint(0, width - rect_width)\n        y = np.random.randint(0, height - rect_height)\n\n        if image.is_grayscale:\n            image.data[y : y + rect_height, x : x + rect_width] = np.nan\n        elif image.is_rgb:\n            image.data[y : y + rect_height, x : x + rect_width, :] = np.nan\n\n        return image\n\n    @staticmethod\n    def _drop_pixels_spiral(image: Image, ratio: float) -&gt; Image:\n        \"\"\"Drop pixels in a spiral pattern.\"\"\"\n        turns = 3\n        n, m = image.height, image.width\n        center_y, center_x = n // 2, m // 2 \n\n        max_radius = np.min([n, m]) // 2 * ratio\n        y, x = np.meshgrid(np.arange(n), np.arange(m), indexing=\"ij\")\n        y_shifted = y - center_y\n        x_shifted = x - center_x\n\n        r = np.sqrt(x_shifted**2 + y_shifted**2)\n        theta = np.arctan2(y_shifted, x_shifted)\n\n        spiral_pattern = (theta + turns * 2 * np.pi * (r / max_radius)) % (2 * np.pi)\n        mask = (spiral_pattern &lt; np.pi) &amp; (r &lt; max_radius)\n\n        image.data[mask] = np.nan\n\n        return image\n\n    @staticmethod\n    def _conform_to_image_data_reqs(data: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\"Ensure compliance with the Image @data.setter method.\n\n        Args:\n            data (np.ndarray): Input data to be transformed.\n\n        Returns:\n            np.ndarray: Data that can be used by Image.\n        \"\"\"\n        data = np.clip(data, MIN_PIXEL_VALUE, MAX_PIXEL_VALUE)\n        data = data.astype(PIXEL_DATA_TYPE)\n        return data\n</code></pre>"},{"location":"api/image_processor/#gp_retouch.image.image_processor.ImageProcessor.add_noise","title":"add_noise  <code>staticmethod</code>","text":"<pre><code>add_noise(\n    image: Image, method: str = \"gaussian\", **kwargs\n) -&gt; Image\n</code></pre> <p>Taint the image with the noise of your choice.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Image</code> <p>The input image.</p> required <code>method</code> <code>str</code> <p>The noise method of choice: gausian, salt_and_pepper,                     speckle, or uniform. Defaults to \"gaussian\".</p> <code>'gaussian'</code> <code>**kwargs</code> <p>Options to be passed to the individual methods.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Image</code> <code>Image</code> <p>The result with added noise.</p> Source code in <code>gp_retouch/image/image_processor.py</code> <pre><code>@staticmethod\ndef add_noise(image: Image, method: str = \"gaussian\", **kwargs) -&gt; Image:\n    \"\"\"Taint the image with the noise of your choice.\n\n    Args:\n        image (Image): The input image.\n        method (str, optional): The noise method of choice: gausian, salt_and_pepper,\n                                speckle, or uniform. Defaults to \"gaussian\".\n        **kwargs: Options to be passed to the individual methods.\n\n    Returns:\n        Image: The result with added noise.\n    \"\"\"\n    methods = {\n        \"gaussian\": ImageProcessor._add_gaussian_noise,\n        \"salt_and_pepper\": ImageProcessor._add_salt_and_pepper_noise,\n        \"speckle\": ImageProcessor._add_speckle_noise,\n        \"uniform\": ImageProcessor._add_uniform_noise,\n    }\n\n    if method not in methods:\n        raise ValueError(f\"Invalid method '{method}'. Valid methods: {list(methods.keys())}\")\n\n    # Dispatch the requested method\n    return methods[method](copy.deepcopy(image), **kwargs)\n</code></pre>"},{"location":"api/image_processor/#gp_retouch.image.image_processor.ImageProcessor.convert_to_grayscale","title":"convert_to_grayscale  <code>staticmethod</code>","text":"<pre><code>convert_to_grayscale(image: Image) -&gt; Image\n</code></pre> <p>summary.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Image</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>Image</code> <code>Image</code> <p>description</p> Source code in <code>gp_retouch/image/image_processor.py</code> <pre><code>@staticmethod\ndef convert_to_grayscale(image: Image) -&gt; Image:\n    \"\"\"_summary_.\n\n    Args:\n        image (Image): _description_\n\n    Returns:\n        Image: _description_\n    \"\"\"\n    image_copy = copy.deepcopy(image)\n    if image_copy.is_grayscale:\n        return image\n    if image_copy.is_rgb:\n        image_copy.data = np.mean(image_copy.data, axis=2).astype(np.uint8)\n        return image_copy\n</code></pre>"},{"location":"api/image_processor/#gp_retouch.image.image_processor.ImageProcessor.convert_to_rgb","title":"convert_to_rgb  <code>staticmethod</code>","text":"<pre><code>convert_to_rgb(image: Image) -&gt; np.ndarray\n</code></pre> Source code in <code>gp_retouch/image/image_processor.py</code> <pre><code>@staticmethod\ndef convert_to_rgb(image: Image) -&gt; np.ndarray:  # noqa: D102\n    pass\n</code></pre>"},{"location":"api/image_processor/#gp_retouch.image.image_processor.ImageProcessor.downscale","title":"downscale  <code>staticmethod</code>","text":"<pre><code>downscale(original_image: Image, factor: float) -&gt; Image\n</code></pre> <p>Downscale an image by factor.</p> Source code in <code>gp_retouch/image/image_processor.py</code> <pre><code>@staticmethod\ndef downscale(original_image: Image, factor: float) -&gt; Image:\n    \"\"\"Downscale an image by factor.\"\"\"\n    if factor &lt;= 0:\n        raise ValueError(\"The downscale factor must be strictly greater than zero.\")\n    if factor &gt;= 1:\n        raise ValueError(\"The downscale factor must be strictly smaller than one.\")\n    image = copy.deepcopy(original_image)\n    # process the dimensions relative to the size\n    new_shape = (int(image.shape[0] * factor), int(image.shape[1] * factor))\n    if image.is_grayscale:\n        downscaled_data = resize(image.data, new_shape, anti_aliasing=True)\n    if image.is_rgb:\n        downscaled_data = resize(image.data, new_shape + (3,), anti_aliasing=True)\n    image.data = downscaled_data\n    return image\n</code></pre>"},{"location":"api/image_processor/#gp_retouch.image.image_processor.ImageProcessor.drop_pixels","title":"drop_pixels  <code>staticmethod</code>","text":"<pre><code>drop_pixels(\n    image: Image, ratio: float, method: str = \"rnd\"\n) -&gt; Image\n</code></pre> <p>Drop pixels from the image (turn them into NaNs) using the specified method.</p> <p>This method does not transform the image in place.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Image</code> <p>The image to be transformed.</p> required <code>ratio</code> <code>float</code> <p>The ratio of points to be dropped.</p> required <code>method</code> <code>str</code> <p>The method to use for dropping pixels. Defaults to \"rnd\".</p> <code>'rnd'</code> <p>Returns:</p> Name Type Description <code>Image</code> <code>Image</code> <p>A new image with some pixels dropped.</p> Source code in <code>gp_retouch/image/image_processor.py</code> <pre><code>@staticmethod\ndef drop_pixels(image: Image, ratio: float, method: str = \"rnd\") -&gt; Image:\n    \"\"\"Drop pixels from the image (turn them into NaNs) using the specified method.\n\n    This method does not transform the image in place.\n\n    Args:\n        image (Image): The image to be transformed.\n        ratio (float): The ratio of points to be dropped.\n        method (str, optional): The method to use for dropping pixels. Defaults to \"rnd\".\n\n    Returns:\n        Image: A new image with some pixels dropped.\n    \"\"\"\n    if not (0 &lt; ratio &lt; 1):\n        raise ValueError(\"ratio must be a greater than 0 and smaller than 1.\")\n\n    new_image = copy.deepcopy(image)\n\n    # Dispatcher for pixel dropping methods\n    methods = {\n        \"rnd\": ImageProcessor._drop_pixels_random,\n        \"rectangle\": ImageProcessor._drop_pixels_rectangle,\n        \"spiral\": ImageProcessor._drop_pixels_spiral,\n    }\n\n    if method not in methods:\n        raise ValueError(f\"Invalid method '{method}'. Valid ones: {list(methods.keys())}\")\n\n    return methods[method](new_image, ratio)\n</code></pre>"}]}